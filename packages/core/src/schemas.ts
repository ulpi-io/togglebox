/**
 * Zod schemas and TypeScript types for runtime validation and type safety.
 *
 * @remarks
 * All schemas are used for validating HTTP request/response payloads and database operations.
 * TypeScript types are automatically inferred from Zod schemas using z.infer<>.
 */

import { z } from 'zod';

/**
 * Schema for configuration JSON objects.
 *
 * @remarks
 * Accepts a flexible key-value structure where values can be:
 * - string
 * - number
 * - boolean
 * - nested objects (passthrough allows any structure)
 *
 * No enforced schema - applications define their own configuration structure.
 * Size limit: 300KB (to stay within DynamoDB 400KB item limit with metadata).
 *
 * @example
 * ```ts
 * // Valid configuration examples
 * const config1 = {
 *   apiUrl: 'https://api.example.com',
 *   timeout: 5000,
 *   enableLogging: true,
 * };
 *
 * const config2 = {
 *   api: {
 *     baseUrl: 'https://api.example.com',
 *     endpoints: {
 *       users: '/v1/users',
 *       posts: '/v1/posts',
 *     },
 *   },
 *   features: {
 *     darkMode: true,
 *     analytics: false,
 *   },
 *   limits: {
 *     maxRequests: 1000,
 *     rateLimit: 100,
 *   },
 * };
 *
 * // Validate config
 * ConfigSchema.parse(config1); // ✅ Valid
 * ConfigSchema.parse(config2); // ✅ Valid
 *
 * // Size limit validation
 * const tooLarge = { data: 'x'.repeat(350_000) };
 * ConfigSchema.parse(tooLarge); // ❌ Throws: "Config size exceeds 300KB limit"
 * ```
 */
export const ConfigSchema = z.record(
  z.string(),
  z.union([z.string(), z.number(), z.boolean(), z.object({}).passthrough()])
).refine(
  (config) => JSON.stringify(config).length < 300_000,
  { message: 'Config size exceeds 300KB limit (DynamoDB constraint)' }
);

/**
 * Schema for configuration version objects.
 *
 * @remarks
 * Represents an immutable versioned configuration within an environment.
 * Versions are identified by auto-generated ISO timestamps for optimal DynamoDB sorting.
 *
 * **Fields:**
 * - platform: Application/service identifier
 * - environment: Deployment environment (e.g., "production", "staging")
 * - versionTimestamp: Auto-generated ISO-8601 timestamp (e.g., "2024-11-22T10:34:56.789Z")
 * - versionLabel: Optional user-friendly name (e.g., "v1.0.0", "release-2024-11")
 * - isStable: Flag indicating production-ready status
 * - config: Arbitrary JSON configuration data (max 300KB)
 * - createdBy: Email of creator
 * - createdAt: Timestamp when created (same as versionTimestamp)
 *
 * **Immutability:**
 * Once created, versions cannot be modified. To fix errors, create a new version.
 * Only the isStable flag can be changed via separate endpoint (future feature).
 */
export const VersionSchema = z.object({
  platform: z.string(),
  environment: z.string(),
  versionTimestamp: z.string().datetime(),
  versionLabel: z.string().optional(),
  isStable: z.boolean().default(false),
  config: ConfigSchema,
  createdBy: z.string().email(),
  createdAt: z.string().datetime(),
});

/**
 * Schema for environment objects.
 *
 * @remarks
 * Represents a deployment environment within a platform.
 */
export const EnvironmentSchema = z.object({
  platform: z.string(),
  environment: z.string(),
  description: z.string().optional(),
  createdAt: z.string(),
});

/**
 * Schema for platform objects.
 *
 * @remarks
 * Represents a top-level application or service.
 */
export const PlatformSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  createdAt: z.string(),
});

/**
 * Schema for creating a new version (omits auto-generated fields).
 *
 * @remarks
 * versionTimestamp and createdAt are auto-generated by the service.
 * Users provide platform, environment, config, and optionally versionLabel.
 */
export const CreateVersionSchema = VersionSchema.omit({
  versionTimestamp: true,
  createdAt: true,
});

/**
 * Schema for cache invalidation requests.
 *
 * @remarks
 * Supports different levels of granularity:
 * - global: true - Invalidate all caches
 * - platform only - Invalidate platform-level caches
 * - platform + environment - Invalidate environment-level caches
 * - platform + environment + version - Invalidate specific version
 */
export const CacheInvalidationSchema = z.object({
  platform: z.string().optional(),
  environment: z.string().optional(),
  version: z.string().optional(),
  global: z.boolean().optional(),
});

/**
 * Schema for successful API responses.
 *
 * Note: data is 'unknown' rather than 'any' for type safety.
 * Consumers must validate/narrow the type before use.
 */
export const ApiResponseSchema = z.object({
  success: z.boolean(),
  data: z.unknown().optional(),
  error: z.string().optional(),
  timestamp: z.string(),
});

/**
 * Schema for error API responses.
 *
 * @remarks
 * Standardized error format used across all API endpoints.
 *
 * **Base Fields (always present):**
 * - success: Always false for errors
 * - error: Human-readable error message
 * - timestamp: ISO-8601 timestamp
 *
 * **Optional Fields:**
 * - code: Machine-readable error code (e.g., "API_LIMIT_EXCEEDED", "VALIDATION_FAILED")
 * - details: Array of detailed error messages (for validation errors)
 * - meta: Additional context based on error type:
 *   - retryAfter: Seconds until retry allowed (rate limiting)
 *   - usage/limit: Current usage and limit (quota errors)
 *   - upgradeUrl: URL to upgrade plan (subscription errors)
 *   - requiredPermission/requiredRole: Missing permission/role (auth errors)
 *   - stack: Error stack trace (development mode only)
 *
 * **Examples:**
 *
 * Validation error:
 * ```json
 * {
 *   "success": false,
 *   "error": "Validation failed",
 *   "code": "VALIDATION_FAILED",
 *   "timestamp": "2025-01-01T00:00:00.000Z",
 *   "details": ["email: Invalid email format", "password: Too short"]
 * }
 * ```
 *
 * Rate limiting error:
 * ```json
 * {
 *   "success": false,
 *   "error": "Too many requests",
 *   "code": "RATE_LIMIT_EXCEEDED",
 *   "timestamp": "2025-01-01T00:00:00.000Z",
 *   "meta": { "retryAfter": 45 }
 * }
 * ```
 *
 * Usage limit error:
 * ```json
 * {
 *   "success": false,
 *   "error": "API request limit exceeded",
 *   "code": "API_LIMIT_EXCEEDED",
 *   "timestamp": "2025-01-01T00:00:00.000Z",
 *   "meta": {
 *     "usage": 1000,
 *     "limit": 1000,
 *     "upgradeUrl": "https://example.com/upgrade"
 *   }
 * }
 * ```
 *
 * Permission error:
 * ```json
 * {
 *   "success": false,
 *   "error": "Insufficient permissions",
 *   "code": "INSUFFICIENT_PERMISSIONS",
 *   "timestamp": "2025-01-01T00:00:00.000Z",
 *   "meta": { "requiredPermission": "config:write" }
 * }
 * ```
 */
export const ErrorResponseSchema = z.object({
  success: z.literal(false),
  error: z.string(),
  code: z.string().optional(),
  timestamp: z.string(),
  details: z.array(z.string()).optional(),
  meta: z.record(z.unknown()).optional(),
});

/** Configuration object type - flexible key-value structure */
export type Config = z.infer<typeof ConfigSchema>;

/** Configuration version type */
export type Version = z.infer<typeof VersionSchema>;

/** Environment type */
export type Environment = z.infer<typeof EnvironmentSchema>;

/** Platform type */
export type Platform = z.infer<typeof PlatformSchema>;

/** Create version request type */
export type CreateVersion = z.infer<typeof CreateVersionSchema>;

/** Cache invalidation request type */
export type CacheInvalidation = z.infer<typeof CacheInvalidationSchema>;

/** Standard API response type */
export type ApiResponse = z.infer<typeof ApiResponseSchema>;

/** Error response type */
export type ErrorResponse = z.infer<typeof ErrorResponseSchema>;

/**
 * Schema for feature flag objects.
 *
 * @remarks
 * Represents a feature flag within an environment. Feature flags are mutable
 * (unlike immutable config versions) and represent live toggle state.
 *
 * **Rollout Types:**
 * - simple: Basic on/off toggle (default)
 * - percentage: Gradual rollout based on user hash (0-100%)
 * - targeted: Specific user targeting only
 *
 * **Phased Rollout Fields:**
 * - rolloutType: Type of rollout strategy
 * - rolloutPercentage: Percentage of users to include (0-100)
 * - targetUserIds: Force-in list (always enabled for these users)
 * - excludeUserIds: Force-out list (always disabled for these users)
 * - targetCountries: Country filter (e.g., ["SA", "AE", "KW"])
 * - targetLanguages: Language filter (e.g., ["ar", "en"])
 *
 * @example
 * ```ts
 * // Simple toggle (all users see same state)
 * const darkModeFlag: FeatureFlag = {
 *   platform: 'web',
 *   environment: 'production',
 *   flagName: 'dark-mode',
 *   enabled: true,
 *   rolloutType: 'simple',
 *   createdBy: 'admin@example.com',
 *   createdAt: '2025-01-01T00:00:00Z',
 * };
 *
 * // Percentage rollout (gradual release to 25% of users)
 * const newUIFlag: FeatureFlag = {
 *   platform: 'web',
 *   environment: 'production',
 *   flagName: 'new-ui',
 *   enabled: true,
 *   rolloutType: 'percentage',
 *   rolloutPercentage: 25,
 *   description: 'New UI redesign - rolling out gradually',
 *   createdBy: 'product@example.com',
 *   createdAt: '2025-01-01T00:00:00Z',
 * };
 *
 * // Targeted rollout (beta testers only)
 * const betaFlag: FeatureFlag = {
 *   platform: 'mobile',
 *   environment: 'production',
 *   flagName: 'beta-payment-method',
 *   enabled: true,
 *   rolloutType: 'targeted',
 *   targetUserIds: ['user123', 'user456', 'user789'],
 *   excludeUserIds: ['user999'], // Exclude specific users
 *   description: 'New payment method for beta testers',
 *   createdBy: 'dev@example.com',
 *   createdAt: '2025-01-01T00:00:00Z',
 * };
 *
 * // Country-specific feature (Middle East only)
 * const regionalFlag: FeatureFlag = {
 *   platform: 'web',
 *   environment: 'production',
 *   flagName: 'arabic-support',
 *   enabled: true,
 *   rolloutType: 'targeted',
 *   targetCountries: ['SA', 'AE', 'KW', 'QA', 'BH', 'OM'],
 *   targetLanguages: ['ar'],
 *   description: 'Arabic language support for Middle East',
 *   createdBy: 'i18n@example.com',
 *   createdAt: '2025-01-01T00:00:00Z',
 * };
 *
 * // Combined targeting (country + percentage)
 * const complexFlag: FeatureFlag = {
 *   platform: 'web',
 *   environment: 'staging',
 *   flagName: 'premium-features',
 *   enabled: true,
 *   rolloutType: 'percentage',
 *   rolloutPercentage: 50,
 *   targetCountries: ['US', 'CA'], // Only US and Canada
 *   targetUserIds: ['vip1', 'vip2'], // Force-in VIP users
 *   description: 'Premium features for North America - 50% rollout',
 *   createdBy: 'growth@example.com',
 *   createdAt: '2025-01-01T00:00:00Z',
 * };
 * ```
 */
export const FeatureFlagSchema = z.object({
  platform: z.string(),
  environment: z.string(),
  flagName: z.string(),
  enabled: z.boolean().default(false),
  description: z.string().optional(),
  createdBy: z.string().email(),
  createdAt: z.string(),
  updatedAt: z.string().optional(),

  // Phased rollout fields
  rolloutType: z.enum(['simple', 'percentage', 'targeted']).default('simple'),
  rolloutPercentage: z.number().min(0).max(100).optional(),
  targetUserIds: z.array(z.string()).optional(),
  excludeUserIds: z.array(z.string()).optional(),
  targetCountries: z.array(z.string()).optional(),
  targetLanguages: z.array(z.string()).optional(),
});

/**
 * Schema for creating a new feature flag (omits auto-generated timestamps).
 */
export const CreateFeatureFlagSchema = FeatureFlagSchema.omit({
  createdAt: true,
  updatedAt: true,
});

/**
 * Schema for updating a feature flag (all fields optional for partial updates).
 *
 * @remarks
 * Unlike configs, feature flags are mutable and can be updated in place.
 */
export const UpdateFeatureFlagSchema = CreateFeatureFlagSchema.partial();

/**
 * Schema for toggling a feature flag (convenience endpoint).
 */
export const ToggleFeatureFlagSchema = z.object({
  enabled: z.boolean(),
});

/** Feature flag type */
export type FeatureFlag = z.infer<typeof FeatureFlagSchema>;

/** Create feature flag request type */
export type CreateFeatureFlag = z.infer<typeof CreateFeatureFlagSchema>;

/** Update feature flag request type */
export type UpdateFeatureFlag = z.infer<typeof UpdateFeatureFlagSchema>;

/** Toggle feature flag request type */
export type ToggleFeatureFlag = z.infer<typeof ToggleFeatureFlagSchema>;

/**
 * Schema for feature flag evaluation requests.
 *
 * @remarks
 * All fields are optional:
 * - userId: Required for phased rollout flags (percentage/targeted)
 * - country: Required if flag has country targeting
 * - language: Required if flag has language targeting
 *
 * If required fields are missing, evaluation returns disabled with helpful reason.
 */
export const EvaluateFeatureFlagRequestSchema = z.object({
  userId: z.string().optional(),
  country: z.string().optional(),
  language: z.string().optional(),
});

/**
 * Schema for feature flag evaluation results.
 *
 * @remarks
 * Simple toggles return { enabled } only.
 * Phased rollout flags return { enabled, reason } for debugging.
 */
export const FeatureFlagEvaluationResultSchema = z.object({
  enabled: z.boolean(),
  reason: z.string().optional(),
  flagName: z.string().optional(),
});

/** Evaluation request type */
export type EvaluateFeatureFlagRequest = z.infer<typeof EvaluateFeatureFlagRequestSchema>;

/** Evaluation result type */
export type FeatureFlagEvaluationResult = z.infer<typeof FeatureFlagEvaluationResultSchema>;